# 专题20：Paxos 协议（史上最全、定期更新）


## Paxos 的重要性
Paxos协议/算法是分布式系统中至关重要的协议，其重要性体现在：  
- **大牛观点**：Google Chubby的作者Mike Burrows曾表示，世界上只有一种一致性算法，那就是Paxos，其他算法都是残次品。  
- **学习价值**：理解Paxos与2PC这两个分布式协议后，学习其他分布式协议会变得相当容易。  
- **应用广泛**：Paxos算法及变种算法在分布式系统中应用广泛，基于Paxos的变种包括ZAB（Zookeeper采用的ZAB协议）、Raft；Zookeeper正是通过ZAB协议实现数据一致性。  

在分布式系统中，节点间主要通过消息投递交互，但可能遇到网络问题、进程挂掉/重启/响应缓慢、机器故障等异常，导致消息重复、暂时不可达等问题。而Paxos算法是**基于消息传递且具有高度容错特性的一致性算法**，其作用是在存在上述异常的分布式系统中，快速、正确地让集群内部对某个数据的值达成一致。  


## 拜占庭将军问题
各类Paxos算法介绍中，常会提及“拜占庭将军问题”与“两军问题”（详细介绍可参考相关专项文章）。  

### 问题场景
拜占庭帝国有多支军队，将军们需制定统一行动计划（进攻或撤退），但将军们地理上分隔，仅能通过通讯员通信。而通讯员中可能存在叛徒，会篡改消息欺骗将军，这就是“拜占庭将军问题”。  

### 核心结论
从理论上看，在异步系统和不可靠通道中实现一致性状态是不可能的。因此，研究一致性时通常假设**信道可靠**：  
- 多数系统部署在同一局域网，消息被篡改的概率极低；  
- 因硬件/网络导致的消息不完整问题，可通过简单校验算法避免。  
实际工程实践中，可假设不存在拜占庭问题，即所有消息完整、未被篡改。  


## 拜占庭将军问题与Paxos的关系
拜占庭将军问题由Paxos算法作者莱斯利·兰伯特提出，是点对点通信中的基本问题，其核心含义是：**在不可靠信道上通过消息传递达成一致性是不可能的**。  

因此，Paxos算法的前提是**不存在拜占庭将军问题**，即信道安全可靠、集群节点间传递的消息不会被篡改。  


## Paxos 算法
Paxos算法由分布式技术大师Lamport提出，他通过假想希腊城邦Paxos的选举场景解释该算法：城邦需通过民主提议+投票达成统一决议，但居民无法全程参与，只能不定时参与提议、了解投票进展、表达意见。Paxos算法的目标是让居民按“少数服从多数”原则，最终达成一致意见。  


### 1. 主要角色
Paxos算法中包含三类核心角色，职责如下：  
- **Proposer（提案者/提议者）**：提出一个值，用于投票决议。  
- **Acceptor（附议者/接受者）**：对每个提议进行投票。  
- **Learner（学习者/告知者）**：仅被告知投票结果，不参与投票过程。  

<img width="801" height="486" alt="image" src="https://github.com/user-attachments/assets/0e0d8321-d585-437b-b921-4f5dca7d6710" />


### 2. 提案格式
规定一个提议包含两个字段：`[n, v]`，其中：  
- `n`：提案序号，需具备**全局唯一性**；  
- `v`：提案值，即待决议的具体内容。  


### 3. 执行过程
以“2个Proposer（提案者A、B）+3个Acceptor（附议者X、Y、Z）”的系统为例，分步说明执行流程：  

#### 阶段1：Acceptor处理提议请求
<img width="823" height="507" alt="image" src="https://github.com/user-attachments/assets/92c62623-b646-48ff-977f-ff70ca817b54" />


Acceptor收到提议请求后，根据自身是否接收过提议，按规则处理：  
- **情况1：未接收过任何提议**  
  发送“无历史提案”（[no previous]）的响应，将当前提议`[n1, v1]`记录为本地已接收提议，并承诺**不再接受序号小于n1的提议**。  
  例：Acceptor X收到`[n=2, v=8]`（提案者A发送），因无历史提案，发送[no previous]响应，记录`[2,8]`并承诺不接受n<2的提议；Acceptor Y同理。  

<img width="790" height="512" alt="image" src="https://github.com/user-attachments/assets/79d56e51-8890-4e60-8a46-a58a45a14dd4" />


- **情况2：已接收过提议`[n1, v1]`**  
  收到新提议`[n2, v2]`后：  
  1. 若`n1 > n2`：丢弃新提议请求；  
  2. 若`n1 ≤ n2`：发送包含历史提议`[n1, v1]`的响应，更新本地已接收提议为`[n2, v2]`，并承诺不再接受序号小于n2的提议。  
  例：  
  - Acceptor Z已接收`[n=4, v=5]`（提案者B发送），后续收到提案者A的`[n=2, v=8]`，因2<4，丢弃该请求；  
  - Acceptor X已接收`[n=2, v=8]`，后续收到提案者B的`[n=4, v=5]`，因2≤4，发送`[2,8]`响应，更新本地记录为`[4,5]`并承诺不接受n<4的提议；Acceptor Y同理。  

<img width="803" height="528" alt="image" src="https://github.com/user-attachments/assets/9b037a99-66ef-4f15-95ec-48a1b5e503b3" />


#### 阶段2：Proposer发送接受请求
当Proposer收到**超过一半Acceptor的提议响应**时，可发送接受请求，规则如下：  
- 接受请求的`v`值需取其收到的所有响应中**最大序号对应的v值**。  
  例：  
  - 提案者A收到2个响应后，发送`[n=2, v=8]`接受请求，但此时所有Acceptor已承诺不接受n<4的提议，故请求被丢弃；  
  - 提案者B收到2个响应（含`[2,8]`），取最大v值8，发送`[n=4, v=8]`接受请求。  

<img width="737" height="504" alt="image" src="https://github.com/user-attachments/assets/118fa7a4-e9c1-4638-924d-dee5b4441407" />


#### 阶段3：Acceptor通知Learner与最终决议
- Acceptor收到接受请求后，若请求序号**≥自身承诺的最小序号**，则向所有Learner发送通知；  
- Learner发现**大多数Acceptor接收了某个提议**时，该提议的`v`值即被Paxos算法选定为最终决议。  

<img width="790" height="528" alt="image" src="https://github.com/user-attachments/assets/9320a20d-920d-4dbd-bffa-a8da2fae4fdd" />

### 4. Paxos 算法的一致性
Paxos算法的一致性体现在以下5点：  

1. 每个Proposer提出提案前，需获取**全局唯一、递增的提案编号N**，并赋予提案；  

2. 每个Acceptor接受提案后，会本地记录该提案的编号N；对于Acceptor，仅接受编号大于本地已记录“最大编号（maxN）”的提案；  

3. 众多提案中最终仅能有一个提案被选定；  

4. 一旦某个提案被选定，其他服务器会主动同步（Learn）该提案到本地；  

5. 若没有提案被提出，则不会有提案被选定。  



## 参考文献
1. 《从Paxos到ZooKeeper》  
2. https://angus.nyc/2012/paxos-by-example/  

